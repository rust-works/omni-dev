# ADR-0017: Diff-First AI Analysis

## Status

✅ Accepted

## Context

omni-dev sends a serialized `RepositoryView` to an AI model so the model can
analyse commits and suggest improved commit messages. Several categories of
information are available for each commit: file paths, file-level status codes
(`A`/`M`/`D`), `diff --stat` summaries, the original commit message, and the
full unified diff produced by `git2::DiffFormat::Patch`.

The quality of AI-generated commit messages depends heavily on which information
the prompt emphasises. Four strategies were evaluated:

- **Summary-only analysis.** The model receives file names and `diff --stat`
  line counts. This reveals *which* files changed and the rough magnitude of
  change, but not *what* changed. The model is forced to guess functionality
  from file paths, which produces generic or misleading messages ("update
  utils.rs") rather than descriptions of actual behaviour.

- **File-list-based analysis.** The model receives only file names and status
  codes. This is even less informative than stat summaries — a renamed file
  looks the same as a rewritten one. Messages become almost entirely
  path-derived.

- **AST-based analysis.** Source files are parsed into abstract syntax trees
  and the structural diff is sent to the model. This provides precise
  semantic information but requires language-specific parsers for every
  language in the repository, adds a compile-time dependency per language,
  and produces output that is harder for the model to reason about than
  unified diff format. The implementation cost is disproportionate to the
  benefit for a commit-message tool.

- **Diff-first analysis.** The full unified diff is the primary input. The
  model sees every added, removed, and context line and can determine what
  the code actually does. File paths, stat summaries, and the original message
  are still included as secondary context but are not the basis for message
  generation.

The diff-first approach consistently produces the most accurate commit messages
because the model reasons from actual code changes rather than proxies.

## Decision

We will treat the full unified diff as the primary input when constructing AI
prompts, with all other commit metadata as secondary context.

### Diff generation and storage

`CommitAnalysis::write_diff_to_file()` in `src/git/commit.rs` generates a
unified diff for each commit using `git2::DiffFormat::Patch` and writes it to
`$AI_SCRATCH/diffs/{commit_hash}.diff`. The `$AI_SCRATCH` environment variable
controls the scratch directory location; when unset, `$TMPDIR` (defaulting to
`/tmp`) is used. The `git-root:` prefix variant resolves the path relative to
the repository root. The `CommitAnalysis` struct stores the file path in its
`diff_file` field; the diff content is not held in memory at this stage.

### In-memory loading for AI prompts

`RepositoryViewForAI` is a type alias for `RepositoryView<CommitInfoForAI>`
defined in `src/data.rs`. When `RepositoryViewForAI::from_repository_view()`
is called, each commit's diff file is read from disk into the `diff_content:
String` field of `CommitAnalysisForAI`. The diff content is then embedded
directly in the serialized YAML that forms the AI prompt — "inline" refers to
presence in the serialized output, not in the original data structure.

### Prompt emphasis

The system prompt in `src/claude/prompts.rs` contains explicit `CRITICAL:`
guidance instructing the AI to treat diff analysis as the most important step.
The first analysis rule reads: "MOST IMPORTANT: Read and analyze the diff_file
content to understand what code changes were actually made". The user prompt
embeds the full YAML (including `diff_content`) and repeats the instruction to
read diffs before any other analysis step.

### Fresh mode

`RepositoryViewForAI::from_repository_view_with_options(repo_view, true)`
replaces each commit's `original_message` with a placeholder string. This
forces the AI to generate commit messages solely from the diff content, without
anchoring to the existing message. Fresh mode is the strongest expression of
the diff-first principle: when enabled, the diff is not merely primary — it is
the only substantive input.

### Progressive diff reduction

When a prompt exceeds the model's token budget, `build_prompt_fitting_budget()`
in `src/claude/client.rs` applies a four-level fallback:

| Level        | Content included                                            |
|--------------|-------------------------------------------------------------|
| Full         | Complete line-by-line unified diff                          |
| Truncated    | Diff trimmed at newline boundaries with a truncation marker |
| StatOnly     | `diff --stat` summary only (no line-level diff)             |
| FileListOnly | File names and status codes only                            |

At each reduction level a warning is logged so the user knows the AI received
less context. Truncation is proportional: each commit's diff is cut by a share
proportional to its size relative to the total. The system always starts at
Full and falls through only when the budget is exceeded, preserving as much
diff detail as possible.

## Consequences

**Positive:**

- **Accurate commit messages.** The AI reasons from actual code changes —
  added functions, modified logic, deleted tests — rather than inferring
  intent from file paths or directory names. This produces messages that
  describe *what the code does*, not *where the code lives*.

- **Language-agnostic.** Unified diff format works for any file type without
  language-specific tooling. Adding a new language to the repository requires
  no changes to the analysis pipeline.

- **Fresh mode enables unbiased generation.** When the original message is
  hidden, the AI cannot be anchored by a vague or incorrect existing message.
  This is particularly useful for bulk re-messaging of poorly documented
  commit histories.

- **Graceful degradation under token pressure.** The four-level fallback
  ensures that prompts always fit the model's context window. The system
  preserves as much diff detail as possible before falling back to summaries,
  and each reduction is logged for transparency.

**Negative:**

- **Large diffs consume significant token budget.** A commit that touches many
  files can produce a diff that dominates the context window, leaving little
  room for other commits in a batch or for the model's reasoning. The
  progressive reduction strategy mitigates this but cannot eliminate it —
  at the FileListOnly level the model has very little to work with.

- **Disk I/O for scratch files.** Every analysed commit writes a diff file
  to the scratch directory and reads it back when constructing the AI prompt.
  For repositories with many commits this adds I/O overhead, though in
  practice the files are small and the scratch directory is typically on a
  fast local filesystem or tmpfs.

**Neutral:**

- **Diff format is opaque for binary files.** Binary files produce a
  placeholder line in unified diff format rather than meaningful content. The
  AI falls back to file paths and status codes for these files, which is the
  same information the summary-only and file-list strategies would provide.
  This is an inherent limitation of text-based diff, not a regression from
  alternatives.

- **Token estimation is heuristic.** The budget-fitting logic uses a
  characters-per-token heuristic (3.5 chars/token with a 10% safety margin)
  rather than an exact tokeniser. This means the system occasionally
  over-reduces or under-reduces by a small margin. The safety margin is
  calibrated to err on the side of fitting, so prompts are never rejected for
  being slightly over budget.
